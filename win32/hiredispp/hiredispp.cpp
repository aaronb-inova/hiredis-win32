/*
 * hiredispp.cpp
 * This is based on the original hiredispp.h by petrohi @https://github.com/petrohi/hiredispp
 * It has been modified to not rely on boost, but a full boost dependency for just this one
 *  module wasn't worth it.  It is being used under agreement of the 
 *   original boost license agreement it was released with:
  Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
 */

#include "hiredispp.h"
#include <sstream>
#include <iterator>

namespace hiredispp
{

    // The utf8_codecvt_facet is borrowed from <boost/detail/utf8_codecvt_facet.hpp> and maintains
    //  their copyright.  It is borrowed here to prevent a full boost dependency for just this one class
        // Copyright (c) 2001 Ronald Garcia, Indiana University (garcia@osl.iu.edu)
        // Andrew Lumsdaine, Indiana University (lums@osl.iu.edu).
        // Distributed under the Boost Software License, Version 1.0. (See accompany-
        // ing file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
    struct utf8_codecvt_facet :
        public std::codecvt<wchar_t, char, std::mbstate_t>  
    {
    public:
        explicit utf8_codecvt_facet(std::size_t no_locale_manage=0)
            : std::codecvt<wchar_t, char, std::mbstate_t>(no_locale_manage) 
        {}
    protected:
        virtual std::codecvt_base::result do_in(
            std::mbstate_t& state, 
            const char * from,
            const char * from_end, 
            const char * & from_next,
            wchar_t * to, 
            wchar_t * to_end, 
            wchar_t*& to_next
        ) const;

        virtual std::codecvt_base::result do_out(
            std::mbstate_t & state, const wchar_t * from,
            const wchar_t * from_end, const wchar_t*  & from_next,
            char * to, char * to_end, char * & to_next
        ) const;

        bool invalid_continuing_octet(unsigned char octet_1) const {
            return (octet_1 < 0x80|| 0xbf< octet_1);
        }

        bool invalid_leading_octet(unsigned char octet_1)   const {
            return (0x7f < octet_1 && octet_1 < 0xc0) ||
                (octet_1 > 0xfd);
        }

        // continuing octets = octets except for the leading octet
        static unsigned int get_cont_octet_count(unsigned   char lead_octet) {
            return get_octet_count(lead_octet) - 1;
        }

        static unsigned int get_octet_count(unsigned char   lead_octet);

        // How many "continuing octets" will be needed for this word
        // ==   total octets - 1.
        int get_cont_octet_out_count(wchar_t word) const ;

        virtual bool do_always_noconv() const throw() { return false; }

        // UTF-8 isn't really stateful since we rewind on partial conversions
        virtual std::codecvt_base::result do_unshift(
            std::mbstate_t&,
            char * from,
            char * /*to*/,
            char * & next
        ) const 
        {
            next = from;
            return ok;
        }

        virtual int do_encoding() const throw() {
            const int variable_byte_external_encoding=0;
            return variable_byte_external_encoding;
        }

        // How many char objects can I process to get <= max_limit
        // wchar_t objects?
        virtual int do_length(
            const std::mbstate_t &,
            const char * from,
            const char * from_end, 
            std::size_t max_limit
            ) const;

        // Largest possible value do_length(state,from,from_end,1) could return.
        virtual int do_max_length() const throw () {
            return 6; // largest UTF-8 encoding of a UCS-4 character
        }
    };

    template<>
    const std::basic_string<char> RedisConst<char>::Nil = "**NIL**";

    template<>
    const std::basic_string<wchar_t> RedisConst<wchar_t>::Nil = L"**NIL**";

    template<>
    const std::basic_string<char> RedisConst<char>::InfoSeparator = ":";

    template<>
    const std::basic_string<wchar_t> RedisConst<wchar_t>::InfoSeparator = L":";

    template<>
    const std::basic_string<char> RedisConst<char>::InfoCrLf = "\r\n";

    template<>
    const std::basic_string<wchar_t> RedisConst<wchar_t>::InfoCrLf = L"\r\n";


    template<>
    void RedisEncoding<wchar_t>::decode(const char* data, size_t size, std::basic_string<wchar_t>& string)
    {
        const size_t bufferSize = 512;
        wchar_t buffer[bufferSize];

        string.resize(0);

        if (size)
        {
            std::codecvt_base::result result = std::codecvt_base::partial;

            while (result == std::codecvt_base::partial)
            {
                wchar_t* bufferIt;
                const char* dataIt;

                std::mbstate_t conversionState = std::mbstate_t();
                result = std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t> >(std::locale(std::locale::classic(),
                        new utf8_codecvt_facet)).in(conversionState, data, data + size, dataIt, buffer, buffer + bufferSize, bufferIt);

                string.append(buffer, bufferIt);
                size -= (dataIt - data);
                data = dataIt;
            }

            if (result == std::codecvt_base::error)
            {
            }
        }
    }

    template<>
    void RedisEncoding<wchar_t>::encode(const std::basic_string<wchar_t>& src,
                                        std::ostream& dst)
    {
        const size_t bufferSize = 512;
        char buffer[bufferSize];
        size_t size = src.size();

        if (size)
        {
            std::ostream_iterator<char> out(dst);
            std::codecvt_base::result result = std::codecvt_base::partial;
            char* bufferIt;
            const wchar_t* stringBegin = src.c_str();
            const wchar_t* stringIt;

            while (result == std::codecvt_base::partial)
            {
                std::mbstate_t conversionState = std::mbstate_t();
                result = std::use_facet<std::codecvt<wchar_t, char, std::mbstate_t> >
                    (std::locale(std::locale::classic(), new utf8_codecvt_facet))
                    .out(conversionState, stringBegin, stringBegin+size, stringIt, buffer,
                         buffer+bufferSize, bufferIt);

                std::copy(buffer, bufferIt, out);
                size -= (stringIt - stringBegin);
                stringBegin = stringIt;
            }

            if (result == std::codecvt_base::error)
            {
            }
        }
    }

    template<>
    void RedisEncoding<wchar_t>::decode(const std::string& data,
                                               std::basic_string<wchar_t>& string)
    {
        decode(data.c_str(), data.size(), string);
    }

    template<>
    void RedisEncoding<wchar_t>::encode(const std::basic_string<wchar_t>& string,
                                               std::string& data)
    {
        std::ostringstream out;
        encode(string, static_cast<std::ostream&>(out));
        data=out.str();
    }


}
